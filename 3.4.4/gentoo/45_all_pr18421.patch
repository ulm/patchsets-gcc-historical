#! /bin/sh -e

# DP: Proposed patch to fix PR18421 and PR16719.

dir=
if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
    dir="$3/"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch)
        patch $pdir -f --no-backup-if-mismatch -p1 < $0
        ;;
    -unpatch)
        patch $pdir -f --no-backup-if-mismatch -R -p1 < $0
        ;;
    *)
        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
        exit 1
esac
exit 0

From: Bernardo Innocenti <bernie@develer.com>
Sender: gcc-patches-owner@gcc.gnu.org
To: gcc-patches <gcc-patches@gcc.gnu.org>
Cc: Peter Barada <peter@the-baradas.com>,
        "Tarani, Andrea" <andrea.tarani@gilbarco.com>,
        Andreas Schwab <schwab@suse.de>, Roger Sayle <roger@eyesopen.com>
Subject: m68k: Fix PR18421 and PR16719
Date: Thu, 09 Jun 2005 04:21:42 +0200

Hello,

this is a reiteration of an ancient patch posted by
Peter Barada here:

  http://gcc.gnu.org/ml/gcc-patches/2004-12/msg00405.html

Patch was later approved here:

  http://gcc.gnu.org/ml/gcc-patches/2005-02/msg01519.html


Unfortunately, running the testsuite on m68k-pc-linux-gnu
revealed a few strange regressions, and the patch was never
committed.

I think I've now found the damn bug.  These checks:

 if (regno + GET_MODE_SIZE (mode) / 4 < 8)
 if (regno + GET_MODE_SIZE (mode) / 4 < 16)

would disallow registers D7 and A7 with SImode.

The following patch just changes "<" to "<=" to
fix the problem.  If it looks sane, I'll re-run
the testsuite on m68k-pc-linux-gnu.

If any of you has access to a fast m68k box with
an already bootstrapped mainline GCC, I'd be happy
to sit back and wait for the results :-)



gcc/
2004-12-06  Peter Barada  <peter@the-baradas.com>

	PR middle-end/16719
	PR middle-end/18421
	* config/m68k/m68k.h (HARD_REGNO_MODE_OK): Disallow bytes
	in address registers.
	* config/m68k/m68k.c (hard_regno_mode_ok): Likewise.
	* config/m68k/m68k.md: Replace 's' with 'i' in 4th
	alternative of addsi3_5200.

Index: gcc-4.0.0/gcc/config/m68k/m68k-protos.h
===================================================================
RCS file: /cvs/uberbaum/gcc/config/m68k/m68k-protos.h,v
retrieving revision 1.17
diff -c -3 -p -r1.17 m68k-protos.h
*** gcc-4.0.0/gcc/config/m68k/m68k-protos.h	22 Oct 2004 12:47:24 -0000	1.17
--- gcc-4.0.0/gcc/config/m68k/m68k-protos.h	6 Dec 2004 15:54:05 -0000
*************** extern rtx legitimize_pic_address (rtx, 
*** 53,58 ****
--- 53,59 ----
  
  #endif /* RTX_CODE */
  
+ extern bool m68k_regno_mode_ok (int, enum machine_mode);
  extern int flags_in_68881 (void);
  extern bool use_return_insn (void);
  extern void override_options (void);
Index: gcc-4.0.0/gcc/config/m68k/m68k.c
===================================================================
RCS file: /cvs/uberbaum/gcc/config/m68k/m68k.c,v
retrieving revision 1.143
diff -c -3 -p -r1.143 m68k.c
*** gcc-4.0.0/gcc/config/m68k/m68k.c	9 Nov 2004 10:13:09 -0000	1.143
--- gcc-4.0.0/gcc/config/m68k/m68k.c	6 Dec 2004 15:54:06 -0000
*************** m68k_hard_regno_rename_ok (unsigned int 
*** 3445,3447 ****
--- 3445,3480 ----
  
    return 1;
  }
+ 
+ /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.
+    On the 68000, the cpu registers can hold any mode except bytes in address
+    registers, but the 68881 registers can hold only SFmode or DFmode.  */
+ bool
+ m68k_regno_mode_ok (int regno, enum machine_mode mode)
+ {
+   if (regno < 8)
+     {
+ 	/* Data Registers, can hold aggregate if fits in.  */
+ 	if (regno + GET_MODE_SIZE (mode) / 4 <= 8)
+ 	  return true;
+     }
+   else if (regno < 16)
+     {
+ 	/* Address Registers, can't hold bytes, can hold aggregate if
+ 	   fits in.  */
+ 	if (GET_MODE_SIZE (mode) == 1)
+ 	  return false;
+ 	if (regno + GET_MODE_SIZE (mode) / 4 <= 16)
+ 	  return true;
+     }
+   else if (regno < 24)
+     {
+       /* FPU registers, hold float or complex float of long double or
+ 	   smaller.  */
+ 	if ((GET_MODE_CLASS (mode) == MODE_FLOAT
+ 	     || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)
+ 	    && GET_MODE_UNIT_SIZE (mode) <= 12)
+ 	  return true;
+     }
+   return false;
+ }
Index: gcc-4.0.0/gcc/config/m68k/m68k.h
===================================================================
RCS file: /cvs/uberbaum/gcc/config/m68k/m68k.h,v
retrieving revision 1.122
diff -c -3 -p -r1.122 m68k.h
*** gcc-4.0.0/gcc/config/m68k/m68k.h	9 Nov 2004 10:13:09 -0000	1.122
--- gcc-4.0.0/gcc/config/m68k/m68k.h	6 Dec 2004 15:54:06 -0000
***************
*** 555,571 ****
    m68k_hard_regno_rename_ok (OLD_REG, NEW_REG)
  
  /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.
!    On the 68000, the cpu registers can hold any mode but the 68881 registers
!    can hold only SFmode or DFmode.  */
  
  #define HARD_REGNO_MODE_OK(REGNO, MODE) \
!   (((REGNO) < 16					\
!     && !((REGNO) < 8 && (REGNO) + GET_MODE_SIZE (MODE) / 4 > 8))	\
!    || ((REGNO) >= 16 && (REGNO) < 24				        \
!        && (GET_MODE_CLASS (MODE) == MODE_FLOAT		\
! 	   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)		\
!        && GET_MODE_UNIT_SIZE (MODE) <= 12))
! 
  
  /* Value is 1 if it is a good idea to tie two pseudo registers
     when one has mode MODE1 and one has mode MODE2.
--- 555,565 ----
    m68k_hard_regno_rename_ok (OLD_REG, NEW_REG)
  
  /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.
!    On the 68000, the cpu registers can hold any mode except bytes in
!    address registers, the 68881 registers can hold only SFmode or DFmode.  */
  
  #define HARD_REGNO_MODE_OK(REGNO, MODE) \
!   m68k_regno_mode_ok ((REGNO), (MODE))
  
  /* Value is 1 if it is a good idea to tie two pseudo registers
     when one has mode MODE1 and one has mode MODE2.
Index: gcc-4.0.0/gcc/config/m68k/m68k.md
===================================================================
RCS file: /cvs/uberbaum/gcc/config/m68k/m68k.md,v
retrieving revision 1.80
diff -c -3 -p -r1.80 m68k.md
*** gcc-4.0.0/gcc/config/m68k/m68k.md	6 Aug 2004 07:14:56 -0000	1.80
--- gcc-4.0.0/gcc/config/m68k/m68k.md	6 Dec 2004 15:54:07 -0000
***************
*** 1850,1856 ****
  (define_insn "*addsi3_5200"
    [(set (match_operand:SI 0 "nonimmediate_operand" "=m,?a,?a,r")
  	(plus:SI (match_operand:SI 1 "general_operand" "%0,a,rJK,0")
! 		 (match_operand:SI 2 "general_src_operand" "d,rJK,a,mrIKLs")))]
    "TARGET_COLDFIRE"
    "* return output_addsi3 (operands);")
  
--- 1850,1856 ----
  (define_insn "*addsi3_5200"
    [(set (match_operand:SI 0 "nonimmediate_operand" "=m,?a,?a,r")
  	(plus:SI (match_operand:SI 1 "general_operand" "%0,a,rJK,0")
! 		 (match_operand:SI 2 "general_src_operand" "d,rJK,a,mrIKLi")))]
    "TARGET_COLDFIRE"
    "* return output_addsi3 (operands);")
  



-- 
  // Bernardo Innocenti - Develer S.r.l., R&D dept.
\X/  http://www.develer.com/
